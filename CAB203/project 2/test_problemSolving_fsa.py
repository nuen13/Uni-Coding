import os
import sys
import traceback
import warnings
from random import choice, randint, seed
from string import ascii_lowercase

seed(0)   # <------------- modify the random behaviour by changing the seed

# WARNING!  Do not edit this file!
# If modify this file then it might not catch errors in your project code.


# Keep track of modules that project uses so we can warn if there are any unsupported imports
modules_before = set(sys.modules.keys())
import problemSolvingFSA as P
modules_after = set(sys.modules.keys())

# when running with Pytest, the current working directory may not be the one
# containing the script.  Find directory containing the script so we can
# easily find test files
scriptDirectory = os.path.dirname(__file__)


# Many of these tests use a transcript of a sequence of messages and the expected response
# like ('connect', 'ready')
# if using pytest, use the -v or -vv option to get a complete diff between your transcript and the expected transcript

def randomPart():
   length = randint(1, 20)
   return ''.join(choice(ascii_lowercase) for _ in range(length))

def randomMailbox():
   return '.'.join(randomPart() for _ in range(randint(1, 5)))

def randomDomain():
   return '.'.join(randomPart() for _ in range(randint(1, 4))) + choice([ '.com', '.org'])

def runEmailParserBot(*correctTranscript):
   state = None
   transcript = []
   for message, _ in correctTranscript:
      r, state = P.emailParserBot(message, state)
      transcript.append((message, r))
   
   assert correctTranscript == tuple(transcript)

def testFSA_runs():
   P.emailParserBot('connect', None)

def testFSA_connect():
   runEmailParserBot(
      ('connect', 'ready')
   )

def testFSA_reset():
   runEmailParserBot(
      ('connect', 'ready')
   )
   # running again to make sure that we can reset the program by passing state=None
   runEmailParserBot(
      ('connect', 'ready')
   )

def testFSA_connect():
   runEmailParserBot(
      ('connect', 'ready'),
      ('disconnect', 'goodbye')
   )

def testFSA_connectTwice():
   runEmailParserBot(
      ('connect', 'ready'),
      ('connect', 'busy')
   )

def testFSA_mailbox1():
   runEmailParserBot(
      ('connect', 'ready'),
      ('mailbox', 'enter email address'),
      ('me@here.com', 'me'),
      ('disconnect', 'goodbye')
   )

def testFSA_mailbox2():
   runEmailParserBot(
      ('connect', 'ready'),
      ('mailbox', 'enter email address'),
      ('blahblah@qut.com', 'blahblah'),
      ('mailbox', 'enter email address'),
      ('robot@robot.com', 'robot'),
      ('disconnect', 'goodbye')
   )

def testFSA_MailboxRandom():
   addresses = ( (randomMailbox(), randomDomain()) for _ in range(20) )
   transcript = [ ('connect', 'ready') ]
   for m, d in addresses:
      transcript.append( ('mailbox', 'enter email address'))
      transcript.append( ( f'{m}@{d}', m) )
   runEmailParserBot(*transcript)


def testFSA_domain1():
   runEmailParserBot(
      ('connect', 'ready'),
      ('domain', 'enter email address'),
      ('me@here.com', 'here.com'),
      ('disconnect', 'goodbye')
   )
   
def testFSA_domain2():
   runEmailParserBot(
      ('connect', 'ready'),
      ('domain', 'enter email address'),
      ('blahblah@qut.com', 'qut.com'),
      ('domain', 'enter email address'),
      ('robot@robot.com', 'robot.com'),
      ('disconnect', 'goodbye')
   )

def testFSA_DomainRandom():
   addresses = ( (randomMailbox(), randomDomain()) for _ in range(20) )
   transcript = [ ('connect', 'ready') ]
   for m, d in addresses:
      transcript.append( ('domain', 'enter email address'))
      transcript.append( ( f'{m}@{d}', d) )
   runEmailParserBot(*transcript)

def testFSA_mixed():
   runEmailParserBot(
      ('connect', 'ready'), 
      ('disconnect', 'goodbye'),
      ('connect', 'ready'),
      ('connect', 'busy'),
      ('mailbox', 'enter email address'),
      ('blahblah@qut.com', 'blahblah'),
      ('domain', 'enter email address'),
      ('blahblah@qut.org', 'qut.org'),
      ('connect', 'busy'),
      ('connect', 'busy'),
      ('mailbox', 'enter email address'),
      ('wrong', 'error'),
      ('wrong again', 'error'),
      ('blahblah@qut.com', 'blahblah'),
      ('domain', 'enter email address'),
      ('disconnect', 'error'),
      ('blahblah@qut.com', 'qut.com'),
      ('disconnect', 'goodbye'), 
      ('mailbox', 'error')
   )

def testFSA_errors1():
   for token in [ 'mailbox', 'domain', 'disconnect', 'blahblah@qut.com', 'blahblah' ]:
      runEmailParserBot(
         (token, 'error')
      )

def testFSA_errors2():      
   for token in [ 'blahblah', 'blahblah@qut.com' ]:
      runEmailParserBot(
         ('connect', 'ready'),
         (token, 'error')
      )

def testFSA_errors3():
   for token in [ 'connect', 'mailbox', 'domain', 'disconnect', 'blahblah' ]:
      runEmailParserBot(
         ('connect', 'ready'),
         ('mailbox', 'enter email address'),
         (token, 'error'),
         ('blahblah@qut.com', 'blahblah')
      )

def testFSA_errors4():
   for token in [ 'connect', 'mailbox', 'domain', 'disconnect', 'blahblah' ]:
      runEmailParserBot(
         ('connect', 'ready'),
         ('domain', 'enter email address'),
         (token, 'error'),
         ('blahblah@qut.com', 'qut.com'),
         ('disconnect', 'goodbye')
      )

def testVersionOK():
   if sys.version_info[0] != 3:
      warnings.warn("You are using Python version 2.  You need to use Python version 3.9 or higher.")
      sys.exit()
   minor = sys.version_info[1]
   if minor < 9:
      warnings.warn(f"You are using Python version 3.{minor}.  Use Python version 3.9 or higher.")
   
   if minor > 10:
      warnings.warn(f"You are using Python version 3.{minor}.  The marking environment uses Python version 3.10.  Be careful not to use language features from later versions.")

def testModulesOK():
   allowed_modules = { 'probability','digraphs', 'csv', 'graphs', 'collections', '_csv', 're', 'numpy', 'problemSolvingFSA', 'typing',  'pickle', 'cython_runtime', 'hashlib', '_ctypes', 'hmac', 'secrets', 'ctypes', '_cython_0_29_24', '_sha3', '_hashlib', '_pickle', '_blake2', '_compat_pickle' }
   usedModules = modules_after - modules_before
   problemModules = { m for m in usedModules if m.split('.')[0] not in allowed_modules }
   if problemModules:
      warnings.warn(f"You have imported one or more modules which are not on the list of pre-approved modules.  Please check that it is needed and gain approval from the unit coordinator.  In some cases these may be imported by another module, eg. numpy, in which case there is no problem.\nImported modules: {problemModules}")
      

if __name__ == "__main__":      
   testsToDo =  { name: f for name, f in locals().items() if callable(f) and name.startswith('test') }
   allpassed = True
   numpassed = 0
   for name, test in testsToDo.items():
      print(f'Running {name}...')
      try:
         test()
         print('Passed.')
         numpassed += 1
      except AssertionError as e:
         allpassed = False
         
         traceback.print_exc()
         print(e)         
         print(f'Failed {name}.')
      print('----------------------------------------------------------------------------------------')
   
   print(f'Passed {numpassed} out of {len(testsToDo)} tests.')
   if allpassed: 
      print('All tests passed.')
   else:
      print('There were failed tests.')

   print(f'Python version {sys.version}')

